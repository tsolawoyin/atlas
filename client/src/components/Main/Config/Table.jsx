import { useState } from "react";
import { motion } from "motion/react";
import { v4 as uuidv4 } from "uuid";
import { isToday } from "date-fns";

function Table({
  choosen,
  selected,
  setSelected,
  setChoosen,
  setConfigHelper,
}) {
  let [merge, setMerge] = useState("Merge");
  let [error, setError] = useState("");
  let [openTab, setOpenTab] = useState(isToday(localStorage.getItem("lastPracticeRecommend")));

  // sure it will be a little bit sophisticated but it's a nice feature
  // a very nice feature
  // omo no be small thing I write here oooo...
  // omase oooo....
  // lolzzz.. the old me sef na crazy shit... made ooo
  function select(e, c, op) {
    if (op == "delete") {
      let choice = choosen.filter((e) => e.id != c.id);
      if (c.selected) setSelected(selected - 1); // undo selection by default as well.
      setChoosen(choice);
      e.stopPropagation();
    } else {
      if (!c.selected) {
        setSelected(selected + 1);
        setChoosen((draft) => {
          let choice = draft.find((d) => d.id == c.id);
          if (choice) choice.selected = true;
        });
      } else {
        setSelected(selected - 1);
        setChoosen((draft) => {
          let choice = draft.find((d) => d.id == c.id);
          if (choice) choice.selected = false;
        });
        setError("");
      }
    }
  }
  // that's all for input...
  // normally at the end of the day, the code for this one will be more crazy...
  function handleInput(e, c) {
    e.preventDefault();

    setChoosen((draft) => {
      let choice = draft.find((d) => d.id == c.id);
      // silently understand their intentions
      // no too long error messages. shey you get...
      if (0 < Number(e.target.value) && Number(e.target.value) <= 60)
        choice.qty = Number(e.target.value);
      else {
        choice.qty = 60
      }
    });
  }

  function handleMerge() {
    // true, once merge is clicked, it should be disabled...
    let selections = choosen.filter((c) => c.selected);

    if (selections.length <= 1) {
      setError("Can't merge single selection");
      return;
    }

    let unselected = choosen.filter((c) => !c.selected); // unselected stuffs...

    if (selections.find((e) => e.type == "multiple")) {
      setError("Can't merge Multiple");
      return;
    }
    // do not do anything.

    let quantity = selections.reduce((a, s) => a + s.qty, 0); // this will return the quantity

    let selectionObj = {
      name: "Multiple",
      subject: selections,
      topic: selections.length,
      qty: quantity,
      type: "multiple",
      id: uuidv4(),
      selected: false,
    };

    if (quantity <= 60) {
      if (merge == "Merge") {
        setMerge("Confirm");
      } else {
        setChoosen(unselected.concat(selectionObj));
        setError("");
        setSelected(selected - selections.length);
        setMerge("Merge");
      }
    } else {
      setError(
        "Adjust total number of questions to be less than or equal to 60"
      );
    }
  }

  // Code generated by chatGPT
  //   function distributeQuestionsRandomly(selectedTopics, totalQuestions) {
  //     let numTopics = selectedTopics.length;
  //     if (numTopics === 0) return [];

  //     // Step 1: Give each topic at least 1 question
  //     let baseAllocation = Array(numTopics).fill(1);
  //     let remainingQuestions = totalQuestions - numTopics;

  //     // Step 2: Generate n-1 random cut points for remaining questions
  //     let cuts = Array.from({ length: numTopics - 1 }, () => Math.floor(Math.random() * (remainingQuestions + 1)));

  //     // Sort the cuts
  //     cuts.sort((a, b) => a - b);

  //     // Step 3: Assign distributed values
  //     let distributed = [];
  //     let prev = 0;

  //     for (let i = 0; i < numTopics - 1; i++) {
  //         let qCount = cuts[i] - prev;
  //         distributed.push({ ...selectedTopics[i], qty: baseAllocation[i] + qCount });
  //         prev = cuts[i];
  //     }

  //     // Assign remaining to the last topic
  //     distributed.push({ ...selectedTopics[numTopics - 1], qty: baseAllocation[numTopics - 1] + (remainingQuestions - prev) });

  //     return distributed;
  // }
  function distributeQuestionsRandomly(selectedTopics, totalQuestions) {
    let numTopics = selectedTopics.length;
    if (numTopics === 0) return [];

    // Generate n-1 random cut points
    let cuts = Array.from({ length: numTopics - 1 }, () => Math.floor(Math.random() * (totalQuestions + 1)));

    // Sort the cuts
    cuts.sort((a, b) => a - b);

    // Assign distributed values
    let distributed = [];
    let prev = 0;

    for (let i = 0; i < numTopics - 1; i++) {
      let qCount = cuts[i] - prev;
      distributed.push({ ...selectedTopics[i], qty: qCount });
      prev = cuts[i];
    }

    // Assign remaining to the last topic
    distributed.push({ ...selectedTopics[numTopics - 1], qty: totalQuestions - prev });

    return distributed;
  }

  function handleAutoMerge() {
    let selections = choosen.filter(c => c.selected); // shey you get...
    // If selection is 1, no need to auto merge anything....
    let unselected = choosen.filter((c) => !c.selected); // unselected stuffs...

    if (selections.length <= 1) {
      setError("Can't Auto merge single selection");
      return
    }
    // If there is multiple in the selection, we ain't going to merge anything...
    if (selections.find(e => e.type == "multiple")) {
      setError("Can't merge Multiple");
      return
    }

    // the thing now is that I have to run an
    let desiredQuantityOfQuestions = Number(prompt("Enter number of questions")); // nice and asy

    if (desiredQuantityOfQuestions) {
      // capping desiredQuantityOfQuestion 60
      if (desiredQuantityOfQuestions < 0 || desiredQuantityOfQuestions > 60) {
        desiredQuantityOfQuestions = 60; // max it to 60...
      }
      // this will be the  representative object... normally.

      // representative...
      let selectionObj = {
        name: "Multiple",
        subject: distributeQuestionsRandomly(selections, desiredQuantityOfQuestions).filter(selection => selection.qty), // remove ones with zero... shey you get
        topic: selections.length,
        qty: desiredQuantityOfQuestions,
        type: "multiple",
        id: uuidv4(),
        selected: false, // something like this...
      }

      setChoosen(unselected.concat(selectionObj)); // hmmm.. let's see how it goes...
      setSelected(selected - selections.length); // olo far sha.... Ati ronu jina...
      setError("");
      // nice and easy...
    } else {
      alert("Value must be a number.");
    }

  }



  return (
    <div>
      <table className="table">
        <thead>
          <tr>
            <td>Subject(s)</td>
            <td>Topic(s)</td>
            <td>#</td>
            <td></td>
          </tr>
        </thead>
        <tbody>
          {choosen.map((c, i) => {
            return (
              <motion.tr
                // this is not a joke... omo... na mad algorithm just dey here normally...
                // I am going to reuse this code obviously...
                key={c.id}
                className={c.selected ? "is-selected is-warning" : ""}
                onClick={(e) => select(e, c)}
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                transition={{ delay: i / 10 + 0.1 }}
              >
                <td>{c.name}</td>
                <td>
                  {c.type != "multiple"
                    ? c.topic.length <= 10
                      ? c.topic
                      : c.topic.slice(0, 7) + "..."
                    : c.topic}
                </td>
                <td>
                  {!c.selected ? (
                    c.qty
                  ) : (
                    <input
                      className="input is-small"
                      choice={c}
                      type="number"
                      placeholder={c.qty}
                      onClick={(e) => e.stopPropagation()}
                      onInput={(e) => handleInput(e, c)}
                      disabled={c.type == "multiple" ? true : false}
                    />
                  )}
                </td>
                <td>
                  <span
                    className="delete"
                    onClick={(e) => select(e, c, "delete")}
                  ></span>
                </td>
              </motion.tr>
            );
          })}
        </tbody>
      </table>
      <div id="table-btns">
        {choosen.length ? (
          <div style={{
            display: "flex",
            justifyContent: "space-between",
            // background: "blue",
            width: "100%"
          }}>
            <button
              className="button is-small add-btns"
              type="button"
              onClick={() => {
                setConfigHelper(true);
              }}
              // disabled={!openTab}
            >
              Open tab
            </button>
            <button className="button is-small is-warning" onClick={() => {
              setChoosen([]); // shikena
            }}>Clear all</button>
          </div>
        ) : null}

        {selected > 0 ? (
          <>
            <button
              className="button is-small add-btns"
              type="button"
              onClick={handleMerge}
            >
              {merge}
            </button>
            <button className="button is-small add-btns" type="button" onClick={handleAutoMerge}>
              Auto Merge
            </button>
          </>

        ) : null}
      </div>

      {error == "" ? null : <p className="has-text-danger">{error}</p>}
    </div>
  );
}

export default Table;
